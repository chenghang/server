自我介绍：
面试官你好!我是南京邮电大学电子与信息工程专业的一名研二学生，很幸运能够参加贵部门的面试！
我本科也是毕业于南京邮电大学，本科期间学校开设了C语言、C语言程序设计、计算机网络、微机原理等计算机基础课程，使我对编程有了一定的了解。
研究生期间又自学了c++、linux操作系统以及网络编程的知识，先后参加了两个项目，2019年AIIDE星际争霸赛，使用c++语言实现一个boot，用代码打游戏，我负责制定游戏策略并实现，以及添加了多个兵种，通过这个项目锻炼了我对c++语言的使用。随后个人完成web静态服务器项目，支持静态资源访问，长连接以及超时断开，能处理400、403、404等常见错误。该项目可扩展性强，可以边学习边拓展和实践。

项目设计思路：
1.首先为项目设计一个整体的架构，这里采用的是基于事件驱动的reactor并发模型。
2.然后项目要实现哪几部分功能，I/O多路复用、线程池、超时断开、缓冲区等。
3.然后分析每一部分功能之间的逻辑关系，各部分功能之间是如何交互的。
4.逐个设计功能模块，包括数据结构的选择，需要类内部操作函数的实现以及与其他功能模块实现交互的外部接口的实现。
5.测试每个功能模块，并实现每个模块之间的联合编译。
6.最后实现对项目整体的一个测试。

四核CPU下压力测试结果：
一千并发量六十秒四线程：85万
一千并发量六十秒八线程：70万 




## 简介
**用C++11实现的高性能Web服务器，可处理静态资源请求，支持HTTP长连接及超时断开** 

## 开发工具
- **操作系统**： centos 7
- **编辑器**： vim + Notepad++
- **编译器**： g++ 4.8.5
- **版本控制**： git
- **工程构建**： make
- **调试工具**： gdb
- **压测工具**： webbench

## 技术要点
- 并发模型为Reactor
- 使用Epoll边沿触发+EPOLLONESHOT，非阻塞IO
-为充分利用多核CPU的性能，以多线程的形式实现服务器，并实现线程池避免线程频繁创建销毁造成的系统开销
- 实现基于小根堆的定时器，用于断开超时连接
- 实现可以自动增长的缓冲区，作为HTTP连接的输入和输出缓冲区


项目介绍：
在学习了一定的c++和网络编程的基础知识之后，用C++11实现的高性能Web服务器，可处理静态资源(图片文件等)请求，支持HTTP长连接及超时断开，可以处理常见的400,403和404错误。
一、实现的技术要点有：
1.使用Reactor并发模型。
2.使用Epoll边沿触发的IO多路复用技术+非阻塞IO来高效监听并读取数据。
3.以多线程的形式实现服务器，并实现线程池避免线程频繁创建销毁造成的系统开销。
4.实现基于小根堆的定时器，用于断开超时连接。
5.实现可以自动增长的缓冲区，作为HTTP连接的输入和输出缓冲区。
6.实现使用双缓冲区实现一个异步日志库。
二、要点分析
1.并发模型的选择。
并发模型可分为多进程模型、多线程模型和事件驱动模型三大类：
多进程模型：
每接受一个连接就fork一个子进程，在该子进程中处理该连接的请求。特点是多进程占用系统资源多，进程切换的系统开销大，Linux下最大进程数有限制，不利于处理大并发。
多线程模型：
每接受一个连接就create一个子线程，利用子线程处理这个连接的请求，Linux下有最大线程数限制（进程虚拟地址空间有限），进程频繁创建和销毁造成系统开销，同样不利于处理大并发。
Reactor模式特点：
它要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将事件通知工作线程。除此之外，主线程不做任何其他实质性的工作；读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。
Reactor模式的工作流程：
①主线程往epoll内核事件表中注册socket上的读就绪事件；
②主线程调用epoll_wait等待socket上有数据可读；
③当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列；
④睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件；
⑤主线程调用epoll_wait等到socket可写；
⑥当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列；
⑦睡眠在请求队列上的某个工作线程被唤醒，它向socket上写入服务器处理客户请求的结果。
在我的服务器中主线程负责监听就绪读写事件的到来，一旦有事件到来内核就将注册的内核事件表中的就绪事件拷贝到作为参数传入的epoll_event类型的结构体数组中。epoll_wait返回就绪事件的数量。然后根据结构体中就绪事件的类型将不同的函数对象加入任务队列，等待子线程执行。此外主线程还负责新连接的建立，在主线程中执行建立新连接的回调函数负责建立新连接。
2.多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。ET模式是epoll的高效模式，它对于同一个epoll事件只触发一次，降低了同一个epoll事件重复触发的次数。对于每一次触发加入任务队列等待子线程处理。由于用户接收缓冲区足够大正常情况时一次读取就可以读取完毕。
3.线程池的实现：通过互斥锁+条件变量来实现线程间的同步和互斥。线程池内建立一个数组来管理线程，建立一个先进先出的队列来存放等待执行的函数对象。在线程池的构造函数中使用lambda表达式来书写线程函数并将其加入线程数组。开始时任务队列为空，所有子线程阻塞在cond_.wait()处，等待任务队列不为空。对任务队列的压入和弹出任务要加锁。每次添加任务使用cond_.notify_one()函数来通知一个子线程。在线程池的析构函数中使用join()函数回收线程。
4.基于小根堆定时器的实现：每一个定时器里面存有到期时间以及到期回调函数（关闭连接的回调函数），在创建一个定时器的时候就完成了初始化。每个定时器要被加入一个定时器队列，使用优先权队列来存储定时器，排序规则是到期时间的先后。使用c++11chrono时间库来记录时间。使用各种操作函数对定时器队列进行添加、删除、处理过期事件等操作。对定时器队列进行操作时要上锁。
5.自动增长的缓冲区的实现：缓冲区类包含一个1024字节的字符数组和两个无符号整型数来记录读写位置。读数据时使用readv()函数进行集中读，readv总是先填满一个缓冲区，然后再填下一个。先将数据一次性读出到多个缓冲区，此时如果in_buffer空间不足时，就得重新计算需要增加的缓冲区空间并重新调整字符数组大小，然后将没放下的字符从其他临时缓冲区中拷贝到扩展之后的缓冲区。这样实现了根据接收数据的大小来自动调整的接收缓冲区。同样写数据时往out_buffer中存数据，比较要存入数据的大小和剩余空间大小，当空间不足时，增大out_buffer。最后使用write()函数往内核发送缓冲区写数据。
6.多线程异步日志的实现：
每条日志都有时间戳，这样才能完整追踪系统中的一个事件的来龙去脉。一个日志库大体可以分为前端和后端两部分。前端是供应用程序使用的接口，用于生成日志消息。后端负责把日志消息写到目标文件中。在多线程程序中每个线程有自己的前端，整个程序共用一个后端。所以难点在于将日志文件从多个前端高效的传输到后端。这是一个典型的多生产者-单消费者问题，对消费者（后端）而言，要做到足够大的吞吐量并占用较少资源。
日志库采用c++stream风格，这样用起来更自然，不必费心保持格式字符串与参数类型的一致性可以随用随写，而且是类型安全的。日志库并没用使用标准库中的iostream，而是自己写的LogStream类，这主要是出于性能原因。
多线程程序的日志库要考虑线程安全问题，即多个线程可以并发写日志，多条日志消息不会出现交织。线程安全不难办到，简单的方法就是用一个全局mutex保护I/O，或者每一个线程单独写一个日志文件，但上述两种做法效果堪忧，前者可能造成全部线程抢一个锁，后者可能让业务线程阻塞在写磁盘操作上。多线程程序中多个线程程最好只写一个日志文件，这样分析日志更容易，不必在多个文件中跳来跳去。所以在日志库的后端我们用一个线程负责收集日志消息，并写入日志文件，其他业务线程只管往这个"日志线程"发送日志消息，这称为"异步日志"。在多线程程序中异步日志是必须的，如果由业务线程直接往磁盘写数据的话，写操作往往可能会阻塞数秒之久。
日志库采用双缓冲区技术，基本思路是准备两块buffer：A和B，前端往bufferA填写数据，后端负责把bufferB内容写入文件。当bufferA写满之后交换A和B，让后端负责将bufferA中数据写入文件，而前端则往bufferB中填入新的日志消息，如此反复。用两个buffer的好处是：在往后端传日志消息的时候不必等待磁盘写文件的操作。同时为避免每条日志消息都触发后端日志线程，前端不是将一条条日志消息分别传送给后端而是将多条日志消息拼成一个大的buffer传送给后端，相当于批处理，减少了线程唤醒的频度，降低了开销。另外为了及时将日志消息写入文件，即便bufferA没有满，日志库也会每3秒执行一次上述交换写入操作。
三、遇到的问题：
1.出现大量Bad file descriptor错误
原因是在HttpRequest的析构函数中关闭了连接描述符，但是在delete一个HttpRequest对象后又错误地再关闭一次文件描述符。在低并发时，这个bug没有表现出来，而高并发时，析构函数中关闭的连接描述符立刻被accept4分配给了新的HTTP连接，而这时再次调用close(fd)就错误地把新连接关闭了，这时候对新连接进行操作就会触发Bad file descriptor错误，在webbench压测时会有大量的失败请求。

2.处理超时事件和处理I/O事件的顺序
由于超时事件会断开连接，因此如果先处理超时事件，有可能断开了即将要在I/O事件处理函数中处理的连接，因此需要先处理I/O事件再处理超时事件。

四、面试常问问题总结
1.一个请求到来的具体处理过程？
项目实现了八个大类，首先在主函数中实例化一个HttpServer对象，在httpserver类的构造函数中创建了监听描述符，实例化了httprequest、epoll、线程池、定时器以及往epoll中注册了四类回调函数，然后进入httpserver中的run函数开始运行。当epoll_wait()返回的时候，调用epoll对象中的handlevnent()函数先通过eopll_event中data.ptr获取连接信息，再根据epoll_event结构体数组中就绪事件不同类型将不同的回调函数加入队列。触发线程池中阻塞在任务队列上的子线程，子线程执行线程函数，在线程函数中执行回调函数。以就绪事件为读就绪事件为例，回调函数中从内核缓冲区接收请求报文并解析请求，然后生成相应的响应报文添加到用户输出缓冲区，然后修改该连接的关注事件为可写事件，重新添加计时器然后等待事件就绪之后将数据发送出去。最后数据发送完毕之后再判断是否为长连接，如果为长连接继续修改该连接上epoll关注的事件类型重新添加计时器，否则关闭连接释放该连接占用的资源。
2.400、403、404错误的判断依据？
400：报文解析错误。
403：使用stat结构体是来描述一个linux系统文件属性的结构。判断文件是否为常规文件或者为用户不可读文件。
404：访问的文件没找到。
3.日志通常要记录哪些东西？
1）收到的每条内部消息的ID（还可以包括关键字段、长度、hash等）；
2）收到的每条外部消息的全文；
3）发出的每条消息的全文，每条消息都有全局唯一的ID；
4）关键内部状态的变更。

















